# Опросник (Django REST Framework)

Задача: спроектировать и разработать API для системы опросов пользователей.

Функционал для администратора системы:

- авторизация в системе (регистрация не нужна)
- добавление/изменение/удаление опросов. Атрибуты опроса: название, дата старта, дата окончания, описание. После создания поле "дата старта" у опроса менять нельзя
- добавление/изменение/удаление вопросов в опросе. Атрибуты вопросов: текст вопроса, тип вопроса (ответ текстом, ответ с выбором одного варианта, ответ с выбором нескольких вариантов)

Функционал для пользователей системы:

- получение списка активных опросов
- прохождение опроса: в качестве идентификатора пользователя в API передаётся числовой ID, по которому сохраняются ответы пользователя на вопросы; один пользователь может участвовать в любом количестве опросов
- получение пройденных пользователем опросов с детализацией по ответам (что выбрано) по ID уникальному пользователя

Использовать следующие технологии: Django 2.2.10, Django REST framework.

Результат выполнения задачи:

- исходный код приложения в github (только на github, публичный репозиторий)
- инструкция по разворачиванию приложения (в docker или локально)
- документация по API

### Содержание requirements
  * Django==2.2.16
  * djangorestframework
  * django-rest-swagger
  * drf-yasg

Установим "Django2.2.16" вместо "Django2.2.10", потому что "swagger" требует версию от 16. Не знаю, можно ли считать это провалом задачи.  
Swagger нужен для удобной и автоматической документации API. Своими ручками писать долго.  
Для работы "swagger", установим еще "drf-yasg".  

---

### Инструкция по разворачиванию приложения локально (Ubuntu) для ОПЫТНЫХ

1. Спасибо, что нашли/зашли в этот репозиторий.
2. Не смотрите на мой проект как на говно.
3. Пожалуйста, не нарушаем 2й пункт.
4. Желаю Вам счастья и здоровья.

---

## Инструкция по разворачиванию приложения локально (Ubuntu) для остальных

### Первоначальная загрузка проекта

1. На странице репозитория (https://github.com/YiLAMA/drf_poll) нажать зелёную кнопку скачивания **"Code"**, выбрать HTTPS и скопировауем ссылку из единственного поле, находящееся там.
2. Найти у себя на компе место(папку), куда собираетесь скачать приложение.
3. Нажать правую кнопку мышки по этой папке, далее нажать строчку "Открыть в терминале".
4. В открывшемся терминале написать: **git clone**
- далее, через пробел, вставим скопированную ссылку (нажать ctrl+shift+v), в итоге должно получится:  
```
git clone https://github.com/YiLAMA/drf_poll.git
```
- если у Вас так, то нажимаем кнопку на клавиатуре "Enter".

### Установка и настройка проекта

5. Теперь последовательно вводим (копируем и вставим) следующие строчки:  

*** Не забываем, что скопированное в терминал надо вставить через нажатия кнопок: ctrl+shift+v.
```
cd drf_poll/
pip3 install -r requirements.txt
python3 manage.py makemigrations
python3 manage.py migrate
python3 manage.py createsuperuser
```
- **createsuperuser** создаёт суперпользователя (администратора системы) для нашего проекта.
- После createsuperuser, в терминале нас попросят написать **'Username'** (логин), напишите просто: **admin**
- Далее попросят написать 'Email address', напишите просто: admin@ya.ru
- теперь попросят написать **'Password'** (пароль), напишем также просто: **admin**  
Не бойтесь, если не видите, что пишите. Это нормально, на самом деле там всё пишется и просто не видно.  
- еще раз попросят написать пароль **'Password (again)'**, здесь также пишем: **admin**  
- будут красные сообщения, что ваш пароль слишком легкий и т.п., не бойтесь, этот проект вряд ли кому нужен. Поэтому на вопрос отвечаем да (создаём): пишем в терминале английскую букву "y" и нажимаем "Enter".

### Запуск локального сервера для проекта

6. Осталось запустить наш проект, для этого теперь пишем в терминале следующее и нажимаем "Enter":
```
python3 manage.py runserver
```
- После, Вы должны увидеть примерно такое содержимое ответа в терминале:
```
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).
November 16, 2020 - 05:01:01
Django version 2.2.16, using settings 'drf_poll.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```
- Всё это значит, что вы успешно запустили сервер для проекта.

7. Открываем браузер и пишем адрес нашего локального сервера: http://127.0.0.1:8000/  
*** Не спешите расстраиваться, увидев открытую нерабочую страницу, там будет написано, какие адресные строки рабочие у проекта:
```
http://127.0.0.1:8000/admin/  
http://127.0.0.1:8000/api/  
http://127.0.0.1:8000/api/admin/  
				/polls/  
				/polls/<int:id>  
				/polls/<int:poll_id>/questions/  
				/questions/  
				/questions/<int:id>  
				/ ... и так далее
http://127.0.0.1:8000/api/user/  
				/polls_activ/  
				/answer/  
				/answer/<int:user_id>  
http://127.0.0.1:8000/swagger/  
http://127.0.0.1:8000/redoc/  
```
 **admin/** - это интерфейс администратора.  
**api/...** - это рабочие адреса для наших запросов.  
**swagger/** - это документация API, автоматически создаваемая для нашего проекта.  
**redoc/** - тоже, автоматически создаваемая документация API.  

---

## Документация API

**1.** Всё, что вам необходимо и даже относительно больше, находится по ссылке (http://127.0.0.1:8000/swagger/), там же можно проверить и вручную потестить каждый запрос.

**2.** Если Вы не знаете и не смогли разобраться со swagger, то напишу краткую инструкцию по использованию:


  **2.1.** Конечные адреса сгруппированы следующим образом:
- admin  
- user  

*** При работе с admin, Вас попросят ввести логин и пароль (Помните, Вы создавали супер пользователя "createsuperuser"? Вот те данные здесь и пишем, т.е. логин и пароль - это слово: **admin**  
*** А при работе с user, Вас ничего не попросят. Они доступны для всех.


  **2.2. Запросы POST.** Зелёный цвет.
Теперь создадим запрос, для этого разворачиваем зеленую строчку POST (после раскрытия, вы сразу заметите описание запроса, написанное чуть ниже раскрытой зелёной строчки POST), теперь здесь мы можем увидеть "Model" (модель) наших данные, из чего состоит тело запроса, там указаны название переменных, их значения, типы данных какие, описание и подсказки.  
Поcле того, как ознакомились с телом запроса, нажимаем кнопку "Try it out".
- Как только мы нажмем кнопку "Try it out", значение примера в поле "Тело запроса" станет редактируемым.
- В поле "Example Value" изменяем значения на какие нам надо и нажимаем "Execute". 
Например, мы использовали: **POST /admin/polls/**  
и далее в поле "Example Value", изменили данные на:   
```
{
  "poll_name": "Оценка уровня жизни",
  "str_date": "2020-11-20",
  "end_date": "2020-11-30",
  "poll_description": "Узнаешь, насколько хорошо или плохо ты живешь"
}
```
нажимаем "Execute".  
- Далее, пользовательский интерфейс Swagger отправляет запрос и показывает отправленный curl, а далее идет раздел где показывается ответ (формат ответа будет показан в формате JSON).  


**2.3. Запросы GET.** Синий цвет.


  **2.3.1. Запросы GET без {id}.**
-Разворачиваем любую синюю строчку GET и всё также аналогично видим описание запроса и всё необходимое.
-Нажимаем кнопку "Try it out", далее "Execute" и получаем список всех имеющихся данных по данному запросу.  

*** Заметьте, что GET запросов здесь 2 вида, один простой, а другой с {id}.


  **2.3.2. Запросы GET с {id}.**
- Разворачиваем любую синюю строчку GET с {id} и на этот раз мы можем увидеть поле {id} внутри запроса.
- Нажимаем кнопку "Try it out" и поле активируется, сюда надо ввести цифру (id) записанных данных, которые мы хотим получить, как только написали цифру, нажимаем "Execute" и получаем конкретные данные с указанным {id}.
- Для примера возьмем запрос: **GET /admin/polls/{poll_id}/questions/**  

Это получение всех вопросов определенного Опроса по его ID (Опроса), т.е. чтобы увидеть все вопросы у Опроса "Проверь, не дурак ли ты.", надо написать его id (он у нас цифра 1 будет), заполняем поле {poll_id}, нажимаем "Execute" и в итоге получим ответ:  
```
{
  "Опрос": {
    "id": 1,
    "poll_name": "Проверь, не дурак ли ты.",
    "str_date": "2020-11-16",
    "end_date": "2020-11-26",
    "poll_description": "Описание Дурачка"
  },
  "Вопросы": [
    {
      "id": 1,
      "poll_id": 1,
      "question_text": "Ты Дурак?",
      "question_type": "О"
    },
    {
      "id": 2,
      "poll_id": 1,
      "question_text": "Ты точно не дурак?",
      "question_type": "Т"
    }
  ]
}
```

"question_type" это тип вопроса, их 3 всего:  

"Т" - текстовый ответ;  
"О" - ответ с выбором одного варианта;  
"М" - ответ с выбором нескольких вариантов;


  **2.4. Запросы PUT.** Жёлтый цвет.
*** Заметьте, эти запросы все с {id}.
- Разворачиваем любую желтую строчку PUT с {id}, здесь тоже мы можем увидим поле {id} внутри запроса.
- Нажимаем кнопку "Try it out" и здесь мы должны заполнить тело запроса и также ввести {id}, которую мы хотим изменить, как только написали цифру и поработали с телом запрос, нажимаем "Execute" и получаем ответ успешный, если ошибок не было.  

*** Когда заполняете тело запроса, необязательно каждую строчку оставлять. Можно все строчки удалить и оставить только ту, которую собирались изменить.  
- Для примера возьмем запрос: **PUT /admin/questions/{id}**  
Из прошлого примера, мы помним, что был такой вопрос "Ты точно не дурак?". Мы будем менять этот вопрос. Нажимаем кнопку "Try it out". В поле {id} указываем id вопроса (он у нас 2), далее тело запроса меняем от такого вида:
```
{
  "poll_id": 0,
  "question_text": "string",
  "question_type": "Т"
}
```
на такое:
```
{
  "question_text": "Ты точно не дурак? Подумай еще раз",
}
```
нажимаем "Execute" и всё.  

*** Для проверки, можем повторить пример из **2.3.2** и там увидим измененный этот вопрос, где изменился лишь текст вопроса.


  **2.5. Запросы DELETE.** Красный цвет.
*** Заметьте, эти запросы тоже все с {id}.
- Разворачиваем любую красную строчку DELETE с {id}, здесь мы увидим только поле {id} внутри запроса. Здесь всё просто.
- Нажимаем кнопку "Try it out", пишем {id}, которую мы хотим удалить, нажимаем "Execute" и готово.  

**2.6. Функционал у пользователя системы:**
- **GET /user/polls_activ/** - получение списка активных опросов.
- **POST ​/user​/answer​/** - прохождение опроса: в качестве идентификатора пользователя в API передаётся числовой ID, по которому сохраняются ответы пользователя на вопросы; один пользователь может участвовать в любом количестве опросов.
- **GET ​/user​/answer​/{user_id}** - получение пройденных пользователем опросов с детализацией по ответам (что выбрано) по ID уникальному пользователя.


**3. Некоторые уточнения по созданным моделям (таблицам)**
- Каждый "Вариант ответа" связан с определенным "Вопросом";
- Каждый "Вопрос" связан с определенным "Опросом";
- Каждому "Ответу" привязан определенный Опрос, Вопрос, Вариант ответа и Пользователь;
- Связки по id;
- Пользователь может быть анонимным, ему необязательно заполнять свои поля, достаточно галочки "Аноним";
- Другие условия задачи тоже соблюдены.

---

## Будущие улучшения проекта


- Инструкция по разворачиванию приложение для Windows пользователей (будет чуток отличаться);
- Инструкция по разворачиванию проекта с помощью docker;
- Добавление тестов;
- Добавление "защиты от дураков";
- Более лучше обмозговать модели (таблицы) данных;
- Добавление новых возможностей, как для админа, так и для юзера.


